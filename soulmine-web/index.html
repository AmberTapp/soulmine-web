<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>SoulMine ‚Äî Web3 –ó–Ω–∞–∫–æ–º—Å—Ç–≤–∞</title>
  <script src="https://unpkg.com/@tonconnect/sdk@latest/dist/tonconnect-sdk.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/face-api.js@1.5.0/dist/face-api.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
    body { background: linear-gradient(135deg, #6a0dad, #000046); color: white; padding: 10px; min-height: 100vh; }
    .container { max-width: 600px; margin: 0 auto; }
    .screen { display: none; padding: 15px; }
    .screen.active { display: block; }
    .btn { display: block; width: 100%; padding: 12px; margin: 8px 0; background: #6a0dad; color: white; border: none; border-radius: 10px; font-size: 16px; cursor: pointer; }
    .btn.connected { background: #00d1b2; }
    .btn:hover { transform: scale(1.02); transition: all 0.2s; box-shadow: 0 0 15px rgba(106, 13, 173, 0.5); }
    .nav-btn { padding: 10px; text-align: center; background: rgba(255,255,255,0.1); margin: 5px; border-radius: 8px; cursor: pointer; }
    .nav-btn.active { background: #6a0dad; }
    .nft-item { position: relative; width: 100px; height: 100px; margin: 10px; display: inline-block; border-radius: 10px; overflow: hidden; background: #1a1a2e; }
    .nft-img { width: 100%; height: 100%; object-fit: cover; }
    .nft-overlay { position: absolute; bottom: 0; left: 0; right: 0; background: rgba(0,0,0,0.7); padding: 5px; font-size: 12px; text-align: center; }
    .nft-empty { text-align: center; padding: 40px; color: #aaa; }
    .quest-item { background: rgba(255,255,255,0.1); padding: 15px; margin: 10px 0; border-radius: 10px; }
    .quest-title { font-weight: bold; margin-bottom: 5px; }
    .quest-desc { font-size: 14px; color: #ccc; margin-bottom: 8px; }
    .quest-reward { font-size: 14px; color: #00d1b2; margin-bottom: 8px; }
    .quest-progress { display: flex; align-items: center; margin-bottom: 10px; }
    .progress-bar { width: 100%; height: 10px; background: #333; border-radius: 5px; overflow: hidden; margin-right: 10px; }
    .progress-fill { height: 100%; background: #00d1b2; border-radius: 5px; transition: width 0.3s; }
    .call-record { border-bottom: 1px solid #333; padding: 10px 0; margin: 10px 0; }
    .proposal-item { background: rgba(255,255,255,0.1); padding: 15px; margin: 10px 0; border-radius: 10px; }
    .status-active { color: #ffcc00; }
    .status-passed { color: #00d1b2; }
    .status-rejected { color: #ff4757; }
    .vote-btn { background: #6a0dad; color: white; border: none; padding: 6px 12px; border-radius: 5px; cursor: pointer; }
    .msg { margin: 8px 0; padding: 10px; border-radius: 15px; max-width: 70%; }
    .msg-you { background: #6a0dad; margin-left: auto; text-align: right; }
    .msg-partner { background: rgba(255,255,255,0.2); margin-right: auto; }
    .msg-mining { font-size: 10px; opacity: 0.8; margin-top: 5px; }
    .chat-input { display: flex; margin-top: 10px; }
    .chat-input input { flex: 1; padding: 10px; border: none; border-radius: 20px; }
    .filter-btn { padding: 8px 12px; margin: 5px; background: rgba(255,255,255,0.1); border-radius: 15px; cursor: pointer; }
    .filter-btn.active { background: #6a0dad; }
    #ar-effects { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 9999; overflow: hidden; }
    .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000; justify-content: center; align-items: center; }
    .modal-content { background: white; padding: 30px; border-radius: 15px; text-align: center; max-width: 300px; }
    #video-modal, #searching-modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1001; justify-content: center; align-items: center; }
    video { width: 100%; height: auto; border-radius: 10px; }
    .video-container { display: flex; flex-direction: column; align-items: center; }
    .video-container > div { margin: 10px; }
    #video-timer { font-size: 24px; font-weight: bold; margin: 10px; }
    #video-status { color: #00d1b2; font-size: 16px; margin: 10px; }
    #ai-advice { background: #6a0dad; color: white; padding: 10px; border-radius: 10px; position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 1000; display: none; }
    #ai-message { font-size: 14px; }
    .wallet-info { margin: 10px 0; font-size: 14px; }
    #partner-preview { width: 100px; height: 100px; border-radius: 50%; object-fit: cover; display: none; margin: 15px auto; border: 3px solid #6a0dad; box-shadow: 0 0 15px rgba(106,13,173,0.4); }
    .resource-links { text-align: center; margin: 15px 0; font-size: 14px; }
    .resource-links a { color: #00d1b2; text-decoration: none; margin: 0 8px; }
    .resource-links a:hover { text-decoration: underline; }
  </style>
</head>
<body>
  <div class="container">
    <!-- –¢–æ–Ω-–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ -->
    <div id="main-screen" class="screen active">
      <h2>üíú SoulMine ‚Äî Web3 –ó–Ω–∞–∫–æ–º—Å—Ç–≤–∞</h2>
      <p>–ö–∞–∂–¥–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ = +$LOVE ‚Ä¢ Airdrop, NFT, DAO ‚Äî –≤—Å—ë –∑–¥–µ—Å—å</p>

      <button id="ton-connect-button" class="btn">üîê –ü–æ–¥–∫–ª—é—á–∏—Ç—å TON Wallet</button>
      <div id="wallet-info" class="wallet-info" style="display:none;"></div>
      <p>–ë–∞–ª–∞–Ω—Å: <strong id="profile-balance">–ó–∞–≥—Ä—É–∑–∫–∞...</strong></p>

      <!-- –ü—Ä–µ–≤—å—é –ø–∞—Ä—Ç–Ω—ë—Ä–∞ -->
      <img id="partner-preview" alt="–ü–∞—Ä—Ç–Ω—ë—Ä">

      <div style="margin: 20px 0;">
        <button class="btn" onclick="findRandomPartner()">üíò –ù–∞–π—Ç–∏ —Å–ª—É—á–∞–π–Ω—É—é –ø–∞—Ä—É</button>
        <button class="btn" onclick="startVideoCall()">üìπ –ù–∞—á–∞—Ç—å –≤–∏–¥–µ–æ-–∑–≤–æ–Ω–æ–∫</button>
        <button class="btn" onclick="openChat()">üí¨ –û—Ç–∫—Ä—ã—Ç—å —á–∞—Ç</button>
      </div>

      <div style="margin: 20px 0;">
        <button class="nav-btn" onclick="showScreen('profile')">üë§ –ü—Ä–æ—Ñ–∏–ª—å</button>
        <button class="nav-btn" onclick="showScreen('quests')">üéØ –ö–≤–µ—Å—Ç—ã</button>
        <button class="nav-btn" onclick="showScreen('history')">üìú –ò—Å—Ç–æ—Ä–∏—è</button>
        <button class="nav-btn" onclick="showScreen('dao')">üèõÔ∏è DAO</button>
      </div>

      <div style="margin: 20px 0;">
        <h3>–í–∞—à NFT</h3>
        <div id="nft-container"></div>
      </div>

      <div style="margin: 20px 0;">
        <h3>–°–æ–≤–º–µ—Å—Ç–Ω—ã–µ NFT</h3>
        <div id="couple-nft-section" style="display:none;">
          <div id="couple-nft-container"></div>
        </div>
      </div>

      <!-- –†–µ—Å—É—Ä—Å—ã -->
      <div class="resource-links">
        <a href="https://t.me/LoveSoulMine_Bot" target="_blank">üí¨ –ë–æ—Ç</a> |
        <a href="https://t.me/SoulMineNews" target="_blank">üì£ –ö–∞–Ω–∞–ª</a> |
        <a href="https://tonscan.org/jetton/EQAf1n9pHB4gITeBj4VA6jYKa4QKAs7e1z5SSQY3DnYme-Yj" target="_blank">$LOVE</a>
      </div>

      <div style="margin-top: 30px; font-size: 12px; color: #aaa;">
        <p>–°–æ–∑–¥–∞–Ω–æ –¥–ª—è TON ‚Äî –±–µ–∑–æ–ø–∞—Å–Ω–æ, –ø—Ä–∏–≤–∞—Ç–Ω–æ, —Å –º–∞–π–Ω–∏–Ω–≥–æ–º</p>
      </div>
    </div>

    <!-- –ß–∞—Ç -->
    <div id="chat-screen" class="screen">
      <h2>üí¨ –ß–∞—Ç</h2>
      <div id="messages" style="height: 400px; overflow-y: scroll; margin-bottom: 10px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 10px;"></div>
      <div class="chat-input">
        <input type="text" placeholder="–ù–∞–ø–∏—à–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ..." onkeypress="sendMsg(event)">
        <button onclick="sendMsg()">–û—Ç–ø—Ä–∞–≤–∏—Ç—å</button>
      </div>
      <div style="margin-top: 15px;">
        <button class="btn" onclick="showScreen('main-screen')">‚Üê –ù–∞–∑–∞–¥</button>
      </div>
    </div>

    <!-- –ü—Ä–æ—Ñ–∏–ª—å -->
    <div id="profile" class="screen">
      <h2>üë§ –ü—Ä–æ—Ñ–∏–ª—å</h2>
      <p>–ê–¥—Ä–µ—Å: <code id="profile-address">‚Äî</code></p>
      <p>–ë–∞–ª–∞–Ω—Å: <strong id="profile-balance-profile">‚Äî</strong></p>
      <h3>–í–∞—à–∏ NFT</h3>
      <div id="nft-container-profile"></div>
      <h3>–°–æ–≤–º–µ—Å—Ç–Ω—ã–µ NFT</h3>
      <div id="couple-nft-container-profile"></div>
      <button class="btn" onclick="showScreen('main-screen')">‚Üê –ù–∞–∑–∞–¥</button>
    </div>

    <!-- –ö–≤–µ—Å—Ç—ã -->
    <div id="quests" class="screen">
      <h2>üéØ –ö–≤–µ—Å—Ç—ã</h2>
      <p>–ü—Ä–æ–≥—Ä–µ—Å—Å: <strong id="quests-progress">0/3</strong></p>
      <div id="quests-list"></div>
      <button class="btn" onclick="showScreen('main-screen')">‚Üê –ù–∞–∑–∞–¥</button>
    </div>

    <!-- –ò—Å—Ç–æ—Ä–∏—è –∑–≤–æ–Ω–∫–æ–≤ -->
    <div id="history" class="screen">
      <h2>üìú –ò—Å—Ç–æ—Ä–∏—è –∑–≤–æ–Ω–∫–æ–≤</h2>
      <div id="call-history-list"></div>
      <button class="btn" onclick="showScreen('main-screen')">‚Üê –ù–∞–∑–∞–¥</button>
    </div>

    <!-- DAO -->
    <div id="dao" class="screen">
      <h2>üèõÔ∏è DAO ‚Äî –ì—Ä–∞–∂–¥–∞–Ω–∏–Ω SoulMine</h2>
      <p>–í–∞—à —É—Ä–æ–≤–µ–Ω—å: <strong id="citizen-nft-level">–ù–µ –≤—ã–¥–∞–Ω–æ. –°–æ–≤–µ—Ä—à–∏—Ç–µ –ø–µ—Ä–≤—ã–π –∑–≤–æ–Ω–æ–∫!</strong></p>
      <h3>–ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è</h3>
      <div id="proposals-list"></div>
      <button class="btn" onclick="createProposal()">‚ûï –°–æ–∑–¥–∞—Ç—å –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ</button>
      <button class="btn" onclick="showScreen('main-screen')">‚Üê –ù–∞–∑–∞–¥</button>
    </div>

    <!-- –ú–æ–¥–∞–ª–∫–∞ NFT -->
    <div id="nft-modal" class="modal">
      <div class="modal-content">
        <h2>üéâ –ù–æ–≤—ã–π NFT!</h2>
        <p style="font-size:4em; margin:10px;">"<span id="nft-name">–ù–∞–∑–≤–∞–Ω–∏–µ</span>"</p>
        <button onclick="closeModal()" style="padding:10px 20px; background:#6a0dad; color:white; border:none; border-radius:8px;">–ó–∞–∫—Ä—ã—Ç—å</button>
      </div>
    </div>

    <!-- –ú–æ–¥–∞–ª–∫–∞ –ø–æ–∏—Å–∫–∞ –ø–∞—Ä—Ç–Ω—ë—Ä–∞ -->
    <div id="searching-modal" class="modal">
      <div class="modal-content">
        <h2>üîç –ü–æ–∏—Å–∫ —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞...</h2>
        <p>–ü–æ–¥–æ–∂–¥–∏—Ç–µ, –º—ã –ø–æ–¥–±–µ—Ä—ë–º –≤–∞–º –∏–¥–µ–∞–ª—å–Ω—É—é –ø–∞—Ä—É ‚ù§Ô∏è</p>
      </div>
    </div>

    <!-- –í–∏–¥–µ–æ–∑–≤–æ–Ω–æ–∫ -->
    <div id="video-modal" class="modal">
      <div class="video-container">
        <div>
          <video id="local-video" autoplay muted playsinline></video>
          <video id="remote-video" autoplay playsinline></video>
        </div>
        <div id="video-timer">00:00</div>
        <div id="video-status">–û–∂–∏–¥–∞–Ω–∏–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è...</div>
        <div style="margin-top: 10px;">
          <button class="btn" onclick="endVideoCall()">‚èπÔ∏è –ó–∞–≤–µ—Ä—à–∏—Ç—å –∑–≤–æ–Ω–æ–∫</button>
        </div>
      </div>
    </div>

    <!-- AR-—ç—Ñ—Ñ–µ–∫—Ç—ã -->
    <div id="ar-effects"></div>

    <!-- AR-—Ñ–∏–ª—å—Ç—Ä—ã -->
    <div style="display:none; margin-top: 10px; position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 9999;">
      <button class="filter-btn" onclick="applyFilter('none')">‚ùå –í—ã–∫–ª—é—á–∏—Ç—å</button>
      <button class="filter-btn" onclick="applyFilter('hearts')">‚ù§Ô∏è –°–µ—Ä–¥—Ü–∞</button>
      <button class="filter-btn" onclick="applyFilter('ton')">üíé TON</button>
      <button class="filter-btn" onclick="applyFilter('party')">üéâ –í–µ—á–µ—Ä–∏–Ω–∫–∞</button>
      <button class="filter-btn" onclick="captureMoment()">üì∏ –ó–∞—Ö–≤–∞—Ç–∏—Ç—å</button>
    </div>
  </div>

  <script>
    // === –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ ===
    let userAddress = null;
    let isCalling = false;
    let callStartTime = null;
    let callTimer = null;
    let miningInterval = null;
    let localStream = null;
    let peerConnection = null;
    let dataChannel = null;
    let ws = null;
    let callPartnerAddress = null;
    let isSearching = false;
    let currentFilter = 'none';

    // === –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã ===
    const JETTON_MASTER_ADDRESS = 'EQAf1n9pHB4gITeBj4VA6jYKa4QKAs7e1z5SSQY3DnYme-Yj'; // ‚úÖ –í–∞—à —Ä–µ–∞–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω $LOVE
    const DAO_CONTRACT_ADDRESS = 'EQB...';
    const SIGNALING_SERVER_URL = 'wss://soulmine-signaling.fly.dev';
    const TON_MANIFEST_URL = 'https://soulmine-web.vercel.app/tonconnect-manifest.json';

    // –ü—Ä–æ–≥—Ä–µ—Å—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    let soulAI = {
      emotions: { happy: 0, neutral: 0, surprised: 0, focused: 0 },
      compatibility: 50,
      adviceCooldown: false
    };

    let userBehavior = {
      messagesSent: 0,
      responseTime: [],
      initiatedChats: 0,
      usedVoice: false,
      usedVideo: false
    };

    // –ü—Ä–æ–≥—Ä–µ—Å—Å –ø–∞—Ä—ã
    let coupleProgress = {
      messages: 0,
      days_active: 0,
      compatibility: 50
    };

    // –ò—Å—Ç–æ—Ä–∏—è –∑–≤–æ–Ω–∫–æ–≤
    let callHistory = [];

    // === TON Connect ===
    const connector = new window.TonConnect.UI.Connector({
      manifestUrl: TON_MANIFEST_URL
    });

    const connectBtn = document.getElementById('ton-connect-button');
    const walletInfo = document.getElementById('wallet-info');
    const profileBalance = document.getElementById('profile-balance');
    const nftContainer = document.getElementById('nft-container');
    const coupleNftContainer = document.getElementById('couple-nft-container');
    const coupleNftSection = document.getElementById('couple-nft-section');

    // === –ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ ===
    window.addEventListener('load', () => {
      loadQuests();
      loadCallHistory();
      loadCitizenNFT();
      updateConnectionState();

      // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø—Ä–µ–≤—å—é –ø–∞—Ä—Ç–Ω—ë—Ä–∞ —á–µ—Ä–µ–∑ —Å–µ–∫—É–Ω–¥—É
      setTimeout(showPartnerPreview, 1000);
    });

    // === –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è ===
    async function updateConnectionState() {
      if (connector.connected) {
        userAddress = connector.wallet.account.address;
        connectBtn.textContent = "‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω–æ";
        connectBtn.classList.add('connected');
        walletInfo.style.display = 'block';
        walletInfo.innerHTML = `<strong>–ê–¥—Ä–µ—Å:</strong> ${userAddress.slice(0, 8)}...${userAddress.slice(-6)}`;

        const balance = await getLoveBalance(userAddress);
        profileBalance.textContent = `${balance} $LOVE`;

        connectToSignalingServer();

        setTimeout(() => {
          const deepLink = `https://t.me/LoveSoulMine_Bot?start=wallet_${encodeURIComponent(userAddress)}`;
          window.open(deepLink, '_blank');
        }, 2000);

      } else {
        userAddress = null;
        connectBtn.textContent = "üîê –ü–æ–¥–∫–ª—é—á–∏—Ç—å TON Wallet";
        connectBtn.classList.remove('connected');
        walletInfo.style.display = 'none';
        profileBalance.textContent = "–ó–∞–≥—Ä—É–∑–∫–∞...";
        nftContainer.innerHTML = '<div class="nft-empty">–ü–æ–¥–∫–ª—é—á–∏—Ç–µ –∫–æ—à–µ–ª—ë–∫</div>';
        coupleNftSection.style.display = 'none';
      }
    }

    connector.onStatusChange(updateConnectionState);

    // === –ü–æ–ª—É—á–µ–Ω–∏–µ –±–∞–ª–∞–Ω—Å–∞ $LOVE ===
    async function getLoveBalance(address) {
      try {
        const response = await fetch(`https://tonapi.io/v2/accounts/${address}/jettons`);
        const data = await response.json();
        const balances = data.balances || [];

        for (const jet of balances) {
          if (jet.jetton?.address === JETTON_MASTER_ADDRESS) {
            const amount = parseInt(jet.balance || "0");
            const decimals = jet.jetton.decimals || 9;
            return (amount / (10 ** decimals)).toFixed(4);
          }
        }
        return "0.0000";
      } catch (error) {
        console.error("–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –±–∞–ª–∞–Ω—Å–∞:", error);
        return "‚Äî";
      }
    }

    async function getLoveBalanceRaw(address) {
      try {
        const response = await fetch(`https://tonapi.io/v2/accounts/${address}/jettons`);
        const data = await response.json();
        const balances = data.balances || [];

        for (const jet of balances) {
          if (jet.jetton?.address === JETTON_MASTER_ADDRESS) {
            const amount = BigInt(jet.balance || "0");
            const decimals = jet.jetton.decimals || 9;
            return Number(amount) / (10 ** decimals);
          }
        }
        return 0;
      } catch (error) {
        console.error("–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –±–∞–ª–∞–Ω—Å–∞:", error);
        return 0;
      }
    }

    // === –ó–∞–≥—Ä—É–∑–∫–∞ NFT ===
    async function loadNFTs(address) {
      const container = document.getElementById('nft-container-profile') || document.getElementById('nft-container');
      if (!container) return;
      container.innerHTML = '<div class="nft-empty">–ó–∞–≥—Ä—É–∑–∫–∞ NFT...</div>';
      try {
        const response = await fetch(`https://tonapi.io/v2/nfts?account=${address}&limit=50`);
        const data = await response.json();
        const nfts = data.nft_items || [];

        if (nfts.length === 0) {
          container.innerHTML = '<div class="nft-empty">–£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç NFT</div>';
          return;
        }

        container.innerHTML = '';
        nfts.forEach(nft => {
          const image = nft.previews?.find(p => p.resolution === '100x100')?.url || nft.previews?.[0]?.url || 'https://via.placeholder.com/100';
          const name = nft.metadata?.name || '–ë–µ–∑ –∏–º–µ–Ω–∏';

          const div = document.createElement('div');
          div.className = 'nft-item';
          div.innerHTML = `
            <img src="${image}" class="nft-img" alt="${name}" onerror="this.src='https://via.placeholder.com/100'">
            <div class="nft-overlay">${name}</div>
          `;
          container.appendChild(div);
        });
      } catch (error) {
        container.innerHTML = '<div class="nft-empty">–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ NFT</div>';
        console.error("–û—à–∏–±–∫–∞:", error);
      }
    }

    // === –ü—Ä–µ–≤—å—é –ø–∞—Ä—Ç–Ω—ë—Ä–∞ ===
    function showPartnerPreview() {
      const models = ['model01', 'model02', 'model03', 'model04', 'model05', 'model06', 'model11', 'model44', 'model66'];
      const randomModel = models[Math.floor(Math.random() * models.length)];
      const img = document.getElementById('partner-preview');
      if (img) {
        img.src = `./models/${randomModel}.png`;
        img.style.display = 'block';
      }
    }

    // === –°–æ–≤–º–µ—Å—Ç–Ω—ã–µ NFT ===
    const COUPLE_NFTS = [
      { id: "first_night", name: "–ü–µ—Ä–≤–∞—è –Ω–æ—á—å", required_messages: 50, image: "üåô" },
      { id: "couple_month", name: "–ü–∞—Ä–∞ –º–µ—Å—è—Ü–∞", required_days: 30, image: "üèÜ" },
      { id: "eternal_match", name: "–í–µ—á–Ω–∞—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å", required_compatibility: 99, image: "‚ö°" }
    ];

    function checkCoupleNFTs() {
      COUPLE_NFTS.forEach(nft => {
        if (localStorage.getItem(`soulmine_couple_nft_${nft.id}`)) return;

        let earned = false;
        if (nft.required_messages && coupleProgress.messages >= nft.required_messages) earned = true;
        if (nft.required_days && coupleProgress.days_active >= nft.required_days) earned = true;
        if (nft.required_compatibility && coupleProgress.compatibility >= nft.required_compatibility) earned = true;

        if (earned) {
          localStorage.setItem(`soulmine_couple_nft_${nft.id}`, '1');
          showNFTModal(nft);
          saveCoupleNFT(nft);
        }
      });
    }

    function saveCoupleNFT(nft) {
      const container = document.getElementById('couple-nft-container-profile') || document.getElementById('couple-nft-container');
      if (!container) return;

      const div = document.createElement('div');
      div.className = 'nft-item';
      div.innerHTML = `
        <div style="font-size:2.5em; display:flex; align-items:center; justify-content:center; height:100%;">${nft.image}</div>
        <div class="nft-overlay">${nft.name}</div>
      `;
      container.appendChild(div);
      const section = document.getElementById('couple-nft-section');
      if (section) section.style.display = 'block';
    }

    // === –ö–≤–µ—Å—Ç—ã ===
    const QUESTS = [
      { 
        id: "connect_wallet", 
        title: "–ü–æ–¥–∫–ª—é—á–∏—Ç–µ –∫–æ—à–µ–ª—ë–∫", 
        description: "–ü—Ä–∏–≤—è–∂–∏—Ç–µ —Å–≤–æ–π TON-–∫–æ—à–µ–ª–µ–∫ –∫ SoulMine.",
        goal: 1, 
        progress: 0, 
        reward: { love: 50, nft: "–ù–æ–≤–∏—á–æ–∫ Web3" }, 
        completed: false 
      },
      { 
        id: "50_messages", 
        title: "–û—Ç–ø—Ä–∞–≤—å—Ç–µ 50 —Å–æ–æ–±—â–µ–Ω–∏–π", 
        description: "–û–±—â–∞–π—Ç–µ—Å—å –∏ –∑–∞—Ä–∞–±–∞—Ç—ã–≤–∞–π—Ç–µ $LOVE.",
        goal: 50, 
        progress: 0, 
        reward: { love: 30, nft: "–ë–æ–ª—Ç—É–Ω" }, 
        completed: false 
      },
      { 
        id: "7_days_active", 
        title: "–ë—É–¥—å—Ç–µ –∞–∫—Ç–∏–≤–Ω—ã 7 –¥–Ω–µ–π", 
        description: "–ó–∞—Ö–æ–¥–∏—Ç–µ –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –∫–∞–∂–¥—ã–π –¥–µ–Ω—å.",
        goal: 7, 
        progress: 0, 
        reward: { love: 20, nft: "–í—ã–Ω–æ—Å–ª–∏–≤—ã–π" }, 
        completed: false 
      }
    ];

    function loadQuests() {
      const saved = localStorage.getItem('soulmine_quests');
      if (saved) {
        const parsed = JSON.parse(saved);
        QUESTS.forEach(q => {
          const savedQ = parsed.find(sq => sq.id === q.id);
          if (savedQ) {
            q.progress = savedQ.progress;
            q.completed = savedQ.completed;
          }
        });
      }
    }

    function saveQuests() {
      localStorage.setItem('soulmine_quests', JSON.stringify(QUESTS));
    }

    function renderQuests() {
      const container = document.getElementById('quests-list');
      if (!container) return;

      container.innerHTML = '';
      let completedCount = QUESTS.filter(q => q.completed).length;

      QUESTS.forEach(quest => {
        const percent = Math.min(100, (quest.progress / quest.goal) * 100);
        const isDone = quest.progress >= quest.goal && !quest.completed;

        const div = document.createElement('div');
        div.className = 'quest-item';
        div.innerHTML = `
          <div class="quest-title">${quest.title}</div>
          <div class="quest-desc">${quest.description}</div>
          <div class="quest-reward">–ù–∞–≥—Ä–∞–¥–∞: ${quest.reward.love} $LOVE${quest.reward.nft ? ' + NFT' : ''}</div>
          <div class="quest-progress">
            <div class="progress-bar"><div class="progress-fill" style="--width: ${percent}%"></div></div>
            <span>${quest.progress}/${quest.goal}</span>
          </div>
          <button class="quest-complete-btn" ${isDone ? '' : 'disabled'} onclick="completeQuest('${quest.id}')">
            ${quest.completed ? '–ü–æ–ª—É—á–µ–Ω–æ' : '–ü–æ–ª—É—á–∏—Ç—å'}
          </button>
        `;
        if (quest.completed) div.style.opacity = '0.7';
        container.appendChild(div);
      });

      const progressEl = document.getElementById('quests-progress');
      if (progressEl) progressEl.textContent = `${completedCount}/${QUESTS.length}`;
    }

    function completeQuest(id) {
      const quest = QUESTS.find(q => q.id === id);
      if (!quest || quest.completed) return;

      quest.completed = true;
      addLove(quest.reward.love);
      if (quest.reward.nft) showNFTModal({ name: quest.reward.nft, image: "üéÅ" });
      saveQuests();
      renderQuests();
      upgradeCitizenLevel();

      alert(`üéâ –í—ã –ø–æ–ª—É—á–∏–ª–∏: ${quest.reward.love} $LOVE${quest.reward.nft ? ' –∏ NFT!' : ''}`);
    }

    function incrementQuest(id, amount = 1) {
      const quest = QUESTS.find(q => q.id === id && !q.completed);
      if (quest) {
        quest.progress = Math.min(quest.goal, quest.progress + amount);
        saveQuests();
        renderQuests();
      }
    }

    // === –ò—Å—Ç–æ—Ä–∏—è –∑–≤–æ–Ω–∫–æ–≤ ===
    function loadCallHistory() {
      if (!userAddress) return;
      const saved = localStorage.getItem(`soulmine_call_history_${userAddress}`);
      if (saved) {
        callHistory = JSON.parse(saved);
      }
    }

    function saveCallHistory() {
      if (!userAddress) return;
      localStorage.setItem(`soulmine_call_history_${userAddress}`, JSON.stringify(callHistory));
      if (callHistory.length % 5 === 0) {
        saveToTonStorage(callHistory, `call_history_${userAddress}.json`);
      }
    }

    function renderCallHistory() {
      const container = document.getElementById('call-history-list');
      if (!container) return;

      container.innerHTML = '';

      if (callHistory.length === 0) {
        container.innerHTML = '<p>–ò—Å—Ç–æ—Ä–∏—è –ø—É—Å—Ç–∞</p>';
        return;
      }

      callHistory.slice().reverse().forEach(call => {
        const div = document.createElement('div');
        div.className = 'call-record';
        div.innerHTML = `
          <p><strong>–°–æ–±–µ—Å–µ–¥–Ω–∏–∫:</strong> ${call.partner.slice(0, 6)}...${call.partner.slice(-4)}</p>
          <p><strong>–î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å:</strong> ${call.duration} –º–∏–Ω</p>
          <p><strong>–°–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å:</strong> ${call.compatibility.toFixed(1)}%</p>
          <p><strong>–ó–∞—Ä–∞–±–æ—Ç–∞–Ω–æ:</strong> ${call.earnedLove.toFixed(2)} $LOVE</p>
          <p><strong>–î–∞—Ç–∞:</strong> ${new Date(call.startTime).toLocaleString()}</p>
          <hr>
        `;
        container.appendChild(div);
      });
    }

    // === DAO: –ì—Ä–∞–∂–¥–∞–Ω–∏–Ω –∏ –≥–æ–ª–æ—Å–æ–≤–∞–Ω–∏–µ ===
    function loadCitizenNFT() {
      const levelEl = document.getElementById('citizen-nft-level');
      if (!levelEl) return;

      const nft = localStorage.getItem('soulmine_citizen_nft');
      if (nft) {
        const data = JSON.parse(nft);
        levelEl.textContent = `${data.name} (–£—Ä–æ–≤–µ–Ω—å ${data.level})`;
      } else {
        levelEl.textContent = "–ù–µ –≤—ã–¥–∞–Ω–æ. –°–æ–≤–µ—Ä—à–∏—Ç–µ –ø–µ—Ä–≤—ã–π –∑–≤–æ–Ω–æ–∫!";
      }
    }

    async function awardCitizenNFT() {
      if (localStorage.getItem('soulmine_citizen_nft_issued')) return;

      const citizenNFT = {
        id: "citizen_level_1",
        name: "–ì—Ä–∞–∂–¥–∞–Ω–∏–Ω SoulMine",
        description: "–í–∞—à –≥–æ–ª–æ—Å –≤ DAO. –£—Ä–æ–≤–µ–Ω—å 1.",
        image: "üèõÔ∏è",
        level: 1,
        issuedAt: new Date().toISOString()
      };

      localStorage.setItem('soulmine_citizen_nft', JSON.stringify(citizenNFT));
      localStorage.setItem('soulmine_citizen_nft_issued', 'true');

      showNFTModal(citizenNFT);

      const metadataUrl = await saveToTonStorage(citizenNFT, `citizen_nft_${userAddress}.json`);
      if (metadataUrl) {
        const botUrl = `https://t.me/LoveSoulMine_Bot?start=claim_nft_citizen_${encodeURIComponent(metadataUrl)}`;
        window.open(botUrl, '_blank');
      }

      console.log('üèõÔ∏è –í—ã–¥–∞–Ω–æ NFT –≥—Ä–∞–∂–¥–∞–Ω–∏–Ω–∞ DAO');
    }

    function upgradeCitizenLevel() {
      const citizenStr = localStorage.getItem('soulmine_citizen_nft');
      if (!citizenStr) return;

      const citizen = JSON.parse(citizenStr);
      const totalCalls = callHistory.length;
      const totalMessages = userBehavior.messagesSent;
      const newLevel = Math.min(5, 1 + Math.floor(totalCalls / 5) + Math.floor(totalMessages / 100));

      if (newLevel > (citizen.level || 0)) {
        citizen.level = newLevel;
        citizen.upgradedAt = new Date().toISOString();
        localStorage.setItem('soulmine_citizen_nft', JSON.stringify(citizen));

        saveToTonStorage(citizen, `citizen_nft_${userAddress}.json`).then(url => {
          if (url) {
            const botUrl = `https://t.me/LoveSoulMine_Bot?start=upgrade_nft_level_${newLevel}_url_${encodeURIComponent(url)}`;
            window.open(botUrl, '_blank');
          }
        });

        console.log(`üèõÔ∏è –£—Ä–æ–≤–µ–Ω—å –≥—Ä–∞–∂–¥–∞–Ω–∏–Ω–∞ –ø–æ–≤—ã—à–µ–Ω –¥–æ ${newLevel}`);
        loadCitizenNFT();
      }
    }

    async function loadProposals() {
      const container = document.getElementById('proposals-list');
      if (!container) return;

      container.innerHTML = '<p>–ó–∞–≥—Ä—É–∑–∫–∞ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π...</p>';

      try {
        const proposals = [
          {
            id: 1,
            title: "–î–æ–±–∞–≤–∏—Ç—å —Ñ–∏–ª—å—Ç—Ä '–ö–æ—Ç–∏–∫–∏'",
            description: "AR-—Ñ–∏–ª—å—Ç—Ä —Å –∫–æ—Ç–∏–∫–∞–º–∏ –≤–æ –≤—Ä–µ–º—è –∑–≤–æ–Ω–∫–∞",
            votesFor: 1240,
            votesAgainst: 310,
            totalSupplySnapshot: 50000,
            status: 0
          },
          {
            id: 2,
            title: "–†–∞–∑–¥–∞—Ç—å 10,000 $LOVE –Ω–æ–≤–∏—á–∫–∞–º",
            description: "Airdrop –¥–ª—è –ø–µ—Ä–≤—ã—Ö 1000 –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π",
            votesFor: 890,
            votesAgainst: 610,
            totalSupplySnapshot: 50000,
            status: 0
          }
        ];

        renderProposals(proposals);
      } catch (error) {
        container.innerHTML = `<p>–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: ${error.message}</p>`;
      }
    }

    function renderProposals(proposals) {
      const container = document.getElementById('proposals-list');
      if (!container) return;

      container.innerHTML = '';

      if (proposals.length === 0) {
        container.innerHTML = '<p>–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π</p>';
        return;
      }

      proposals.forEach(p => {
        const totalVotes = p.votesFor + p.votesAgainst;
        const quorum = p.totalSupplySnapshot * 0.05;
        const hasQuorum = totalVotes >= quorum;
        const percentFor = totalVotes > 0 ? (p.votesFor / totalVotes * 100).toFixed(1) : 0;

        let statusText = '‚è≥ –ì–æ–ª–æ—Å–æ–≤–∞–Ω–∏–µ';
        let statusClass = 'status-active';
        if (p.status === 1) { statusText = '‚úÖ –ü—Ä–∏–Ω—è—Ç–æ'; statusClass = 'status-passed'; }
        else if (p.status === 2) { statusText = '‚ùå –û—Ç–∫–ª–æ–Ω–µ–Ω–æ'; statusClass = 'status-rejected'; }

        const div = document.createElement('div');
        div.className = 'proposal-item';
        div.innerHTML = `
          <h3>${p.title}</h3>
          <p>${p.description}</p>
          <p><strong>–ì–æ–ª–æ—Å–æ–≤ "–ó–∞":</strong> ${p.votesFor.toLocaleString()} $LOVE ‚Äî ${percentFor}%</p>
          <p><strong>–ì–æ–ª–æ—Å–æ–≤ "–ü—Ä–æ—Ç–∏–≤":</strong> ${p.votesAgainst.toLocaleString()} $LOVE</p>
          <p><strong>–ö–≤–æ—Ä—É–º:</strong> ${hasQuorum ? '‚úÖ' : '‚ùå'} (–Ω—É–∂–Ω–æ: ${quorum.toLocaleString()} $LOVE)</p>
          <p><strong>–°—Ç–∞—Ç—É—Å:</strong> <span class="${statusClass}">${statusText}</span></p>
          <div style="display:flex; gap:10px; margin-top:10px;">
            <button class="vote-btn" onclick="voteProposal(${p.id}, 1)">üó≥Ô∏è –ó–∞</button>
            <button class="vote-btn" onclick="voteProposal(${p.id}, 0)">üó≥Ô∏è –ü—Ä–æ—Ç–∏–≤</button>
          </div>
          <hr>
        `;
        container.appendChild(div);
      });
    }

    async function voteProposal(proposalId, support = 1) {
      if (!userAddress) {
        alert('–ü–æ–¥–∫–ª—é—á–∏—Ç–µ –∫–æ—à–µ–ª–µ–∫!');
        return;
      }

      try {
        const loveBalance = await getLoveBalanceRaw(userAddress);
        if (loveBalance <= 0) {
          alert('–ù—É–∂–µ–Ω –±–∞–ª–∞–Ω—Å $LOVE –¥–ª—è –≥–æ–ª–æ—Å–æ–≤–∞–Ω–∏—è!');
          return;
        }

        alert(`üó≥Ô∏è –í–∞—à –≥–æ–ª–æ—Å —É—á—Ç–µ–Ω! –í–µ—Å: ${loveBalance} $LOVE\n(–í –¥–µ–º–æ-–≤–µ—Ä—Å–∏–∏ –≥–æ–ª–æ—Å–æ–≤–∞–Ω–∏–µ —ç–º—É–ª–∏—Ä—É–µ—Ç—Å—è)`);

        setTimeout(loadProposals, 2000);

      } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –≥–æ–ª–æ—Å–æ–≤–∞–Ω–∏—è:', error);
        alert('–û—à–∏–±–∫–∞: ' + error.message);
      }
    }

    function createProposal() {
      if (!userAddress) {
        alert('–ü–æ–¥–∫–ª—é—á–∏—Ç–µ –∫–æ—à–µ–ª–µ–∫!');
        return;
      }

      const title = prompt('–ó–∞–≥–æ–ª–æ–≤–æ–∫ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è:');
      if (!title) return;
      const description = prompt('–û–ø–∏—Å–∞–Ω–∏–µ:');
      if (!description) return;

      alert('üìù –ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ —Å–æ–∑–¥–∞–Ω–æ! (–í –¥–µ–º–æ-–≤–µ—Ä—Å–∏–∏ —ç–º—É–ª–∏—Ä—É–µ—Ç—Å—è)');
      setTimeout(loadProposals, 1000);
    }

    // === TON Storage ===
    async function saveToTonStorage(data, filename) {
      try {
        const storageItem = {
          version: "1.0",
          owner: userAddress,
          timestamp: Date.now(),
          data
        };

        const content = btoa(JSON.stringify(storageItem));
        const blob = new Blob([content], { type: 'application/json' });

        const mockStorageUrl = `https://ton-storage.example/${encodeURIComponent(filename)}`;
        console.log('üíæ [–î–ï–ú–û] –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ TON Storage:', filename, '‚Üí', mockStorageUrl);
        return mockStorageUrl;
      } catch (error) {
        console.error('–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –≤ TON Storage:', error);
        return null;
      }
    }

    // === AI: –ê–Ω–∞–ª–∏–∑ —ç–º–æ—Ü–∏–π ===
    async function loadFaceModel() {
      await faceapi.nets.tinyFaceDetector.loadFromUri('/models');
      await faceapi.nets.faceExpressionNet.loadFromUri('/models');
      console.log('‚úÖ –ú–æ–¥–µ–ª—å AI –∑–∞–≥—Ä—É–∂–µ–Ω–∞');
    }

    async function analyzeFacialEmotions(videoElement) {
      if (!videoElement || !videoElement.srcObject) return;
      const detections = await faceapi.detectAllFaces(
        videoElement,
        new faceapi.TinyFaceDetectorOptions()
      ).withFaceExpressions();

      if (detections.length > 0) {
        const expressions = detections[0].expressions;
        updateEmotionStats(expressions);
        generateAISuggestion(expressions);
        sendEmotionSnapshot();
      }
    }

    function updateEmotionStats(expressions) {
      soulAI.emotions.happy += expressions.happy || 0;
      soulAI.emotions.neutral += expressions.neutral || 0;
      soulAI.emotions.surprised += expressions.surprised || 0;
      soulAI.emotions.focused += expressions.concentrating || 0;
    }

    function generateAISuggestion(expressions) {
      if (soulAI.adviceCooldown) return;
      soulAI.adviceCooldown = true;
      setTimeout(() => { soulAI.adviceCooldown = false; }, 8000);

      const adviceEl = document.getElementById('ai-advice');
      const msgEl = document.getElementById('ai-message');
      if (!adviceEl || !msgEl) return;

      adviceEl.style.display = 'block';

      if (expressions.happy > 0.7) {
        msgEl.textContent = "–û–Ω–∞ —É–ª—ã–±–∞–µ—Ç—Å—è ‚Äî –ø—Ä–æ–¥–æ–ª–∂–∞–π —à—É—Ç–∏—Ç—å!";
        showLove(0.5);
      } else if (expressions.neutral > 0.8) {
        msgEl.textContent = "–û–Ω–∞ —Å–æ—Å—Ä–µ–¥–æ—Ç–æ—á–µ–Ω–∞ ‚Äî –∑–∞–¥–∞–π –ª–∏—á–Ω—ã–π –≤–æ–ø—Ä–æ—Å";
      } else if (expressions.surprised > 0.6) {
        msgEl.textContent = "–û–Ω–∞ —É–¥–∏–≤–ª–µ–Ω–∞ ‚Äî —Ä–∞–∑–≤–∏–≤–∞–π —Ç–µ–º—É!";
      } else {
        msgEl.textContent = "–û—Ç–ª–∏—á–Ω–∞—è —Ö–∏–º–∏—è! –ü—Ä–æ–¥–æ–ª–∂–∞–π—Ç–µ üëè";
      }

      setTimeout(() => { adviceEl.style.display = 'none'; }, 6000);
    }

    function updateCompatibility() {
      const total = soulAI.emotions.happy + soulAI.emotions.neutral + soulAI.emotions.surprised + soulAI.emotions.focused;
      if (total === 0) return;

      const happyRatio = soulAI.emotions.happy / total;
      const focusedRatio = soulAI.emotions.focused / total;

      if (happyRatio > 0.3 || focusedRatio > 0.3) {
        coupleProgress.compatibility = Math.min(100, coupleProgress.compatibility + 0.5);
        console.log(`‚ù§Ô∏è –°–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å: ${coupleProgress.compatibility.toFixed(1)}%`);
        sendCompatibilityUpdate();
        checkCoupleNFTs();
      }
    }

    // === DataChannel ===
    function setupDataChannel(channel) {
      dataChannel = channel;

      channel.onopen = () => {
        console.log('üì° DataChannel –æ—Ç–∫—Ä—ã—Ç');
        sendCompatibilityUpdate();
        sendEmotionSnapshot();
      };

      channel.onmessage = (event) => {
        const msg = JSON.parse(event.data);
        console.log('üì© –ü–æ–ª—É—á–µ–Ω–æ –ø–æ DataChannel:', msg);

        switch (msg.type) {
          case 'compatibility_update':
            coupleProgress.compatibility = msg.value;
            const display = document.getElementById('compatibility-display');
            if (display) display.textContent = `${msg.value.toFixed(1)}%`;
            checkCoupleNFTs();
            break;

          case 'emotion_snapshot':
            console.log('–≠–º–æ—Ü–∏–∏ –ø–∞—Ä—Ç–Ω–µ—Ä–∞:', msg.emotions);
            break;

          case 'chat_message':
            appendChatMessage(msg.text, 'partner');
            break;
        }
      };

      channel.onclose = () => {
        console.log('üîå DataChannel –∑–∞–∫—Ä—ã—Ç');
      };
    }

    function sendCompatibilityUpdate() {
      if (dataChannel && dataChannel.readyState === 'open') {
        dataChannel.send(JSON.stringify({
          type: 'compatibility_update',
          value: coupleProgress.compatibility
        }));
      }
    }

    function sendEmotionSnapshot() {
      if (dataChannel && dataChannel.readyState === 'open') {
        dataChannel.send(JSON.stringify({
          type: 'emotion_snapshot',
          emotions: soulAI.emotions
        }));
      }
    }

    // === –í–∏–¥–µ–æ–≤—ã–∑–æ–≤—ã ===
    function initPeerConnection() {
      const config = {
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun1.l.google.com:19302' }
        ]
      };
      peerConnection = new RTCPeerConnection(config);
      console.log('‚úÖ WebRTC —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–æ');

      peerConnection.ondatachannel = (event) => {
        setupDataChannel(event.channel);
      };
    }

    async function startVideoCall(isIncoming = false) {
      if (isCalling) return;
      const modal = document.getElementById('video-modal');
      if (!modal) return;

      modal.style.display = 'flex';

      try {
        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        const localVideo = document.getElementById('local-video');
        if (localVideo) localVideo.srcObject = localStream;

        if (!peerConnection) {
          initPeerConnection();
        }

        localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

        peerConnection.ontrack = (event) => {
          const remoteVideo = document.getElementById('remote-video');
          if (remoteVideo) remoteVideo.srcObject = event.streams[0];
        };

        peerConnection.onicecandidate = (event) => {
          if (event.candidate && ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({
              type: 'candidate',
              candidate: event.candidate,
              to: callPartnerAddress
            }));
          }
        };

        if (isIncoming) {
          // –ñ–¥–µ–º offer —á–µ—Ä–µ–∑ ws
        } else {
          const partner = prompt("–í–≤–µ–¥–∏—Ç–µ –∞–¥—Ä–µ—Å –∫–æ—à–µ–ª—å–∫–∞ —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞ –¥–ª—è –∑–≤–æ–Ω–∫–∞:");
          if (!partner) {
            modal.style.display = 'none';
            return;
          }
          callPartnerAddress = partner;

          const offer = await peerConnection.createOffer();
          await peerConnection.setLocalDescription(offer);

          ws.send(JSON.stringify({
            type: 'offer',
            sdp: offer,
            to: partner
          }));

          console.log('üì§ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ SDP-offer');
        }

        setTimeout(() => {
          const statusEl = document.getElementById('video-status');
          if (statusEl) statusEl.textContent = '–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ';
          callStartTime = new Date();
          startCallTimer();
          startMiningEffect();
          userBehavior.usedVideo = true;
          isCalling = true;

          if (callHistory.length === 0) {
            awardCitizenNFT();
          }
        }, 2000);

        setInterval(() => {
          if (isCalling) {
            const remoteVideo = document.getElementById('remote-video');
            if (remoteVideo && remoteVideo.srcObject) {
              analyzeFacialEmotions(remoteVideo);
              updateCompatibility();
            }
          }
        }, 3000);

        if (!window.faceModelLoaded) {
          await loadFaceModel();
          window.faceModelLoaded = true;
        }

      } catch (error) {
        console.error("‚ùå –û—à–∏–±–∫–∞ –≤ startVideoCall:", error);
        alert("–û—à–∏–±–∫–∞: " + error.message);
        if (modal) modal.style.display = 'none';
      }
    }

    function startCallTimer() {
      callTimer = setInterval(() => {
        const now = new Date();
        const diff = new Date(now - callStartTime);
        const mins = String(diff.getMinutes()).padStart(2, '0');
        const secs = String(diff.getSeconds()).padStart(2, '0');
        const timerEl = document.getElementById('video-timer');
        if (timerEl) timerEl.textContent = `${mins}:${secs}`;
      }, 1000);
    }

    function startMiningEffect() {
      miningInterval = setInterval(() => {
        if (isCalling) {
          showLove(0.3);
          triggerMiningEffect("+0.3 $LOVE");
        }
      }, 30000);
    }

    function endVideoCall() {
      if (callTimer) clearInterval(callTimer);
      if (miningInterval) clearInterval(miningInterval);
      if (localStream) localStream.getTracks().forEach(t => t.stop());
      if (peerConnection) peerConnection.close();
      peerConnection = null;

      const durationMs = callStartTime ? (new Date() - callStartTime) : 0;
      const minutes = Math.floor(durationMs / 60000);

      const callRecord = {
        id: Date.now().toString(36),
        partner: callPartnerAddress,
        startTime: callStartTime?.toISOString() || new Date().toISOString(),
        duration: minutes,
        compatibility: coupleProgress.compatibility,
        emotions: { ...soulAI.emotions },
        earnedLove: minutes * 0.3
      };

      callHistory.push(callRecord);
      saveCallHistory();
      addLove(callRecord.earnedLove);
      upgradeCitizenLevel();

      const statusEl = document.getElementById('video-status');
      if (statusEl) statusEl.textContent = '–í—ã–∑–æ–≤ –∑–∞–≤–µ—Ä—à—ë–Ω';
      setTimeout(() => {
        const modal = document.getElementById('video-modal');
        if (modal) modal.style.display = 'none';
      }, 2000);

      isCalling = false;
      callStartTime = null;
      callPartnerAddress = null;
    }

    // === –°–∏–≥–Ω–∞–ª–∏–Ω–≥ —Å–µ—Ä–≤–µ—Ä ===
    function connectToSignalingServer() {
      if (ws && ws.readyState === WebSocket.OPEN) return;

      ws = new WebSocket(SIGNALING_SERVER_URL);

      ws.onopen = () => {
        console.log('‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω–æ –∫ —Å–∏–≥–Ω–∞–ª—å-—Å–µ—Ä–≤–µ—Ä—É');
        if (userAddress) {
          ws.send(JSON.stringify({ type: 'register', address: userAddress }));
        }
      };

      ws.onmessage = async (event) => {
        const data = JSON.parse(event.data);
        console.log('üì© –ü–æ–ª—É—á–µ–Ω —Å–∏–≥–Ω–∞–ª:', data);

        switch (data.type) {
          case 'offer':
            await handleOffer(data);
            break;
          case 'answer':
            await handleAnswer(data);
            break;
          case 'candidate':
            await handleCandidate(data);
            break;
          case 'call_request':
            if (confirm(`–í—Ö–æ–¥—è—â–∏–π –∑–≤–æ–Ω–æ–∫ –æ—Ç ${data.from}! –ü—Ä–∏–Ω—è—Ç—å?`)) {
              callPartnerAddress = data.from;
              await startVideoCall(true);
              ws.send(JSON.stringify({ type: 'call_accept', to: data.from }));
            } else {
              ws.send(JSON.stringify({ type: 'call_reject', to: data.from }));
            }
            break;
          case 'random_match_found':
            callPartnerAddress = data.partner;
            alert(`üéâ –ù–∞–π–¥–µ–Ω —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫! –ù–∞—á–∏–Ω–∞–µ–º –∑–≤–æ–Ω–æ–∫...`);
            const searchingModal = document.getElementById('searching-modal');
            if (searchingModal) searchingModal.style.display = 'none';
            isSearching = false;
            const matchBtn = document.getElementById('random-match-btn');
            if (matchBtn) matchBtn.textContent = 'üíò –ù–∞–π—Ç–∏ —Å–ª—É—á–∞–π–Ω—É—é –ø–∞—Ä—É';
            await startVideoCall(true);
            break;
        }
      };

      ws.onclose = () => {
        console.log('üîå –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å —Å–µ—Ä–≤–µ—Ä–æ–º –∑–∞–∫—Ä—ã—Ç–æ');
        setTimeout(connectToSignalingServer, 3000);
      };

      ws.onerror = (error) => {
        console.error('‚ùå –û—à–∏–±–∫–∞ WebSocket:', error);
      };
    }

    async function handleOffer(data) {
      if (!peerConnection) {
        initPeerConnection();
        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));
        
        peerConnection.ontrack = (event) => {
          const remoteVideo = document.getElementById('remote-video');
          if (remoteVideo) remoteVideo.srcObject = event.streams[0];
        };
        
        peerConnection.onicecandidate = (event) => {
          if (event.candidate && ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({
              type: 'candidate',
              candidate: event.candidate,
              to: data.from
            }));
          }
        };
      }

      await peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));
      const answer = await peerConnection.createAnswer();
      await peerConnection.setLocalDescription(answer);

      ws.send(JSON.stringify({
        type: 'answer',
        sdp: answer,
        to: data.from
      }));

      console.log('üì® –û—Ç–ø—Ä–∞–≤–ª–µ–Ω answer');
    }

    async function handleAnswer(data) {
      await peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));
      console.log('‚úÖ –ü–æ–ª—É—á–µ–Ω answer, —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ');
    }

    async function handleCandidate(data) {
      await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
    }

    async function findRandomPartner() {
      if (!userAddress) {
        alert('–°–Ω–∞—á–∞–ª–∞ –ø–æ–¥–∫–ª—é—á–∏—Ç–µ –∫–æ—à–µ–ª–µ–∫!');
        return;
      }

      if (isCalling) {
        alert('–ó–∞–≤–µ—Ä—à–∏—Ç–µ —Ç–µ–∫—É—â–∏–π –∑–≤–æ–Ω–æ–∫!');
        return;
      }

      if (isSearching) {
        ws.send(JSON.stringify({ type: 'cancel_search' }));
        isSearching = false;
        const btn = document.getElementById('random-match-btn');
        if (btn) btn.textContent = 'üíò –ù–∞–π—Ç–∏ —Å–ª—É—á–∞–π–Ω—É—é –ø–∞—Ä—É';
        return;
      }

      isSearching = true;
      const btn = document.getElementById('random-match-btn');
      if (btn) btn.textContent = '‚è≥ –û—Ç–º–µ–Ω–∏—Ç—å –ø–æ–∏—Å–∫...';

      ws.send(JSON.stringify({
        type: 'find_random_partner',
        address: userAddress
      }));

      const modal = document.getElementById('searching-modal');
      if (modal) modal.style.display = 'flex';
    }

    // === AR-—Ñ–∏–ª—å—Ç—Ä—ã ===
    function applyFilter(filter) {
      document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
      event.target.classList.add('active');
      currentFilter = filter;

      const effects = document.getElementById('ar-effects');
      if (!effects) return;
      effects.innerHTML = '';

      if (filter === 'hearts') startHeartsEffect();
      else if (filter === 'ton') startTonEffect();
      else if (filter === 'party') startConfettiEffect();
    }

    function startHeartsEffect() {
      const effects = document.getElementById('ar-effects');
      if (!effects) return;

      setInterval(() => {
        if (currentFilter !== 'hearts') return;
        const heart = document.createElement('img');
        heart.src = 'https://cdn-icons-png.flaticon.com/128/833/833472.png';
        heart.style.cssText = `position:absolute;width:${Math.random()*20+20}px;left:${Math.random()*80+10}%;top:80%;opacity:0;transition:top 3s ease,opacity 3s;`;
        effects.appendChild(heart);
        setTimeout(() => { heart.style.top = '10%'; heart.style.opacity = '1'; }, 100);
        setTimeout(() => { heart.remove(); }, 3000);
      }, 800);
    }

    function startTonEffect() {
      const effects = document.getElementById('ar-effects');
      if (!effects) return;

      const tonLogo = document.createElement('img');
      tonLogo.src = 'https://ton.org/assets/logo-circle.svg';
      tonLogo.style.cssText = 'position:absolute;top:10%;right:10%;width:60px;filter:drop-shadow(0 0 10px #6a0dad);opacity:0.9;';
      effects.appendChild(tonLogo);
    }

    function startConfettiEffect() {
      const effects = document.getElementById('ar-effects');
      if (!effects) return;

      ['üéâ', 'üéä', '‚ú®', 'üéà'].forEach(emoji => {
        setTimeout(() => {
          if (currentFilter === 'party') {
            const confetti = document.createElement('div');
            confetti.textContent = emoji;
            confetti.style.cssText = `position:absolute;font-size:20px;left:${Math.random()*100}%;top:-20px;animation:fall-confetti 5s linear forwards;`;
            effects.appendChild(confetti);
          }
        }, Math.random() * 3000);
      });
    }

    function captureMoment() {
      const nftName = currentFilter === 'hearts' ? "–ú–∞–≥–∏—è –ª—é–±–≤–∏" :
                      currentFilter === 'ton' ? "–ß–µ–º–ø–∏–æ–Ω TON" :
                      currentFilter === 'party' ? "–ö–æ—Ä–æ–ª—å –≤–µ—á–µ—Ä–∏–Ω–∫–∏" : "–û–±—ã—á–Ω—ã–π –º–æ–º–µ–Ω—Ç";

      const image = { hearts: "‚ù§Ô∏è", ton: "üíé", party: "üéâ", default: "üì∑" }[currentFilter] || "üì∑";

      showNFTModal({ name: nftName, image });
      addLove(5);
    }

    // === –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ ===
    function showLove(amount) {
      addLove(amount);
    }

    function addLove(amount) {
      if (userAddress) {
        getLoveBalance(userAddress).then(current => {
          const currentNum = parseFloat(current.replace('‚Äî', '0'));
          const newBalance = currentNum + amount;
          const balanceEl = document.getElementById('profile-balance');
          if (balanceEl) balanceEl.textContent = `${newBalance.toFixed(4)} $LOVE`;
          
          const profileBalanceEl = document.getElementById('profile-balance-profile');
          if (profileBalanceEl) profileBalanceEl.textContent = `${newBalance.toFixed(4)} $LOVE`;
        });
      }
    }

    function showNFTModal(nft) {
      const modal = document.getElementById('nft-modal');
      if (!modal) return;
      document.getElementById('nft-name').textContent = `"${nft.name}"`;
      modal.style.display = 'flex';
    }

    function closeModal() {
      const modal = document.getElementById('nft-modal');
      if (modal) modal.style.display = 'none';
    }

    function triggerMiningEffect(text) {
      const effect = document.createElement('div');
      effect.textContent = text;
      effect.style.cssText = `
        position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
        color: #6a0dad; font-weight: bold; font-size: 20px; z-index: 1000;
        opacity: 0; pointer-events: none; text-shadow: 0 0 5px rgba(106, 13, 173, 0.5);
        transition: opacity 0.3s ease-out;
      `;
      document.body.appendChild(effect);
      setTimeout(() => { effect.style.opacity = '1'; }, 10);
      setTimeout(() => { effect.style.opacity = '0'; }, 2000);
      setTimeout(() => { effect.remove(); }, 2500);
    }

    function appendChatMessage(text, sender) {
      const messages = document.getElementById('messages');
      if (!messages) return;
      const msg = document.createElement('div');
      msg.className = sender === 'you' ? 'msg msg-you' : 'msg msg-partner';
      msg.textContent = text;
      messages.appendChild(msg);
      messages.scrollTop = messages.scrollHeight;
    }

    // === –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ —ç–∫—Ä–∞–Ω–æ–≤ ===
    window.showScreen = function(id) {
      const screens = ['main-screen', 'chat-screen', 'profile', 'quests', 'history', 'dao'];
      screens.forEach(s => {
        const el = document.getElementById(s);
        if (el) el.style.display = 'none';
      });
      const target = document.getElementById(id);
      if (target) target.style.display = 'block';

      document.querySelectorAll('.nav-btn').forEach(btn => btn.classList.remove('active'));
      const activeBtn = document.querySelector(`.nav-btn[onclick="showScreen('${id}')"]`);
      if (activeBtn) activeBtn.classList.add('active');

      if (id === 'profile' && connector.connected && userAddress) {
        getLoveBalance(userAddress).then(b => {
          const balanceEl = document.getElementById('profile-balance-profile');
          if (balanceEl) balanceEl.textContent = `${b} $LOVE`;
        });
        loadNFTs(userAddress);
        checkCoupleNFTs();
      }

      if (id === 'quests') renderQuests();
      if (id === 'history') renderCallHistory();
      if (id === 'dao') {
        loadCitizenNFT();
        loadProposals();
      }
    };

    // === –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π ===
    if (connectBtn) {
      connectBtn.onclick = async () => {
        try {
          if (!connector.connected) await connector.connect();
          else await connector.disconnect();
          updateConnectionState();
        } catch (e) { alert("–û—à–∏–±–∫–∞: " + e.message); }
      };
    }

    function openBot() {
      const botUrl = `https://t.me/LoveSoulMine_Bot?start=wallet_${encodeURIComponent(userAddress)}`;
      window.open(botUrl, '_blank');
    }

    function openChannel() {
      const channelUrl = 'https://t.me/SoulMineNews';
      window.open(channelUrl, '_blank');
    }

    function openChat() {
      showScreen('chat-screen');
    }

    function sendMsg(e) {
      if (e && e.key !== 'Enter') return;
      const input = document.querySelector('.chat-input input');
      const value = input.value.trim();
      if (!value) return;

      const messages = document.getElementById('messages');
      if (!messages) return;

      const msg = document.createElement('div');
      msg.className = 'msg msg-you';
      msg.innerHTML = value + '<div class="msg-mining">üí∞ +0.2 $LOVE –∑–∞ –æ—Ç–≤–µ—Ç</div>';
      messages.appendChild(msg);
      messages.scrollTop = messages.scrollHeight;

      input.value = '';
      userBehavior.messagesSent++;
      coupleProgress.messages++;
      incrementQuest("50_messages", 1);
      addLove(0.2);

      if (dataChannel && dataChannel.readyState === 'open') {
        dataChannel.send(JSON.stringify({
          type: 'chat_message',
          text: value
        }));
      }
    }
  </script>

  <style>
    @keyframes fall-confetti {
      to {
        transform: translateY(100vh) rotate(360deg);
        opacity: 0;
      }
    }
  </style>
</body>
</html>